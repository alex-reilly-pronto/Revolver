
/**
 *  Instance of this type can be randomly combined with instance to produce two new offspring instances.
 */
public protocol OnePointCrossoverable {
    
    /**
     Performs one-point crossover between the receiver and `other`.
     
     - parameter generator: Provider of randomness.
     - parameter other:     The second parent, with which the receiver's data is combined.
     
     - returns: Two new instances, generated by combining the `self` and `other`.
     */
    func onePointCrossover(generator: EntropyGenerator, other: Self) -> (first: Self, second: Self)
    
}

/// One-point crossover simulates sexual reproduction of individuals within the population.
/// It combines their chromosomes to create new offspring chromosomes, which are then inserted into the next generation.
public class OnePointCrossover<Chromosome where Chromosome: Randomizable, Chromosome: OnePointCrossoverable>: GeneticOperator<Chromosome> {
    
    /**
     Performs one-point crossover on a pair of selected individuals and inserts their offspring into the next generation.
     
     - parameter selectedIndividuals: Exactly two indices of selected individuals (parents).
     - parameter pool:                Pool of individuals. This object is guaranteed to be in the staging state.
     */
    override public func apply(selectedIndividuals: Selection.IndexSet, pool: MatingPool<Chromosome>) {
        precondition(selectedIndividuals.count == 2, "The selectedIndividuals argument must contain exactly 2 indices.")

        // Retrieve parent chromosomes.
        let firstChromosome = pool.individualAtIndex(selectedIndividuals.first!).chromosome
        let secondChromosome = pool.individualAtIndex(selectedIndividuals.last!).chromosome
        
        // Perform crossover on their underlying data structure.
        let result = firstChromosome.onePointCrossover(entropyGenerator, other: secondChromosome)
        
        // Insert the offspring into new population.
        let firstOffspring = Individual<Chromosome>(chromosome: result.first)
        let secondOffspring = Individual<Chromosome>(chromosome: result.second)
        
        pool.addOffspring(firstOffspring)
        pool.addOffspring(secondOffspring)
    }
    
}
